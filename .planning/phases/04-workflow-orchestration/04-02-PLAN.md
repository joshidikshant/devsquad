---
phase: 04-workflow-orchestration
plan: "02"
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - plugin/skills/workflow-orchestration/scripts/run-workflow.sh
  - plugin/commands/workflow.md
autonomous: true
requirements:
  - ORCH-01
  - ORCH-02
  - ORCH-03
  - ORCH-04

must_haves:
  truths:
    - "run-workflow.sh reads a JSON workflow file and executes each step in order"
    - "Before each destructive step, workflow_gate is called and the step is skipped if rejected"
    - "After each checkpoint step, workflow_checkpoint records a git commit hash into state.json"
    - "After all steps, workflow_validate runs git-health.sh --json and the configured test_command"
    - "On any step failure, rollback hints are printed (git reset --hard <checkpoint_hash>) but never auto-executed"
    - "DEVSQUAD_HOOK_DEPTH=1 is exported at the top to prevent hook re-entry"
    - "The /devsquad:workflow command stub wires to run-workflow.sh"
  artifacts:
    - path: "plugin/skills/workflow-orchestration/scripts/run-workflow.sh"
      provides: "Main workflow driver script"
      exports: []
    - path: "plugin/commands/workflow.md"
      provides: "Command stub for /devsquad:workflow"
      contains: "devsquad:workflow-orchestration"
  key_links:
    - from: "plugin/skills/workflow-orchestration/scripts/run-workflow.sh"
      to: "plugin/skills/workflow-orchestration/scripts/lib-workflow.sh"
      via: "source lib-workflow.sh"
      pattern: "source.*lib-workflow\\.sh"
    - from: "run-workflow.sh step loop"
      to: "workflow_gate"
      via: "destructive field in JSON"
      pattern: "workflow_gate"
    - from: "run-workflow.sh step loop"
      to: "workflow_checkpoint"
      via: "checkpoint field in JSON"
      pattern: "workflow_checkpoint"
    - from: "run-workflow.sh end"
      to: "workflow_validate"
      via: "called after all steps complete"
      pattern: "workflow_validate"
---

<objective>
Create the main workflow driver script and the command stub that wires it to Claude.

Purpose: run-workflow.sh is the core engine — it reads a JSON workflow definition, iterates steps, calls the lib-workflow.sh helpers at the right moments, handles failures with informational rollback hints, and exposes the --dry-run and --skip-gates flags. The workflow.md command stub makes the skill accessible via /devsquad:workflow.

Output: run-workflow.sh (executable, bash -n clean), workflow.md (command stub).
</objective>

<execution_context>
@/Users/Dikshant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Dikshant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@plugin/skills/workflow-orchestration/scripts/lib-workflow.sh
@plugin/lib/state.sh
@plugin/skills/code-generation/scripts/generate-skill.sh
@plugin/commands/generate.md
@.planning/phases/04-workflow-orchestration/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create run-workflow.sh main driver</name>
  <files>plugin/skills/workflow-orchestration/scripts/run-workflow.sh</files>
  <action>
Create `plugin/skills/workflow-orchestration/scripts/run-workflow.sh` following the exact patterns from generate-skill.sh (BASH_SOURCE resolution, while-loop arg parsing, phased output with [N/M] prefix):

```bash
#!/usr/bin/env bash
set -euo pipefail

# ---------------------------------------------------------------------------
# run-workflow.sh — DevSquad Workflow Orchestration Skill
# Reads a JSON workflow definition and executes steps sequentially,
# with permission gates, checkpoint commits, and post-workflow validation.
# ---------------------------------------------------------------------------

# Prevent hook re-entry: hooks check DEVSQUAD_HOOK_DEPTH and skip if >= 1
export DEVSQUAD_HOOK_DEPTH=1

# Resolve plugin root from script location — do NOT rely on CLAUDE_PLUGIN_ROOT
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]:-$0}")" && pwd)"
PLUGIN_ROOT="$(cd "${SCRIPT_DIR}/../../.." && pwd)"

# Source required libraries
source "${PLUGIN_ROOT}/lib/state.sh"
source "${SCRIPT_DIR}/lib-workflow.sh"

# ---------------------------------------------------------------------------
# Argument parsing (while-loop — consistent with Phase 2 locked decision)
# ---------------------------------------------------------------------------
WORKFLOW_FILE=""
DRY_RUN=false
SKIP_GATES=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    --workflow)
      shift
      WORKFLOW_FILE="${1:-}"
      shift
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    --skip-gates)
      SKIP_GATES=true
      shift
      ;;
    --help|-h)
      echo "Usage: run-workflow.sh --workflow <path> [--dry-run] [--skip-gates]"
      echo ""
      echo "Arguments:"
      echo "  --workflow <path>  Path to JSON workflow definition file (required)"
      echo "  --dry-run          Print steps without executing them"
      echo "  --skip-gates       Skip permission gates for destructive steps"
      exit 0
      ;;
    *)
      echo "Unknown argument: $1" >&2
      exit 1
      ;;
  esac
done

# Validate required argument
if [[ -z "$WORKFLOW_FILE" ]]; then
  echo "Error: --workflow is required." >&2
  echo "Usage: run-workflow.sh --workflow <path> [--dry-run] [--skip-gates]" >&2
  exit 1
fi

if [[ ! -f "$WORKFLOW_FILE" ]]; then
  echo "Error: Workflow file not found: ${WORKFLOW_FILE}" >&2
  exit 1
fi

# Check jq dependency
if ! command -v jq &>/dev/null; then
  echo "Error: jq is required but not found. Install jq to use workflow orchestration." >&2
  exit 1
fi

# ---------------------------------------------------------------------------
# Parse workflow definition
# ---------------------------------------------------------------------------
WORKFLOW_NAME=$(jq -r '.name // "unnamed-workflow"' "$WORKFLOW_FILE")
WORKFLOW_DESC=$(jq -r '.description // ""' "$WORKFLOW_FILE")
TEST_COMMAND=$(jq -r '.test_command // ""' "$WORKFLOW_FILE")
STEP_COUNT=$(jq '.steps | length' "$WORKFLOW_FILE")

echo ""
echo "=== DevSquad Workflow Orchestration ==="
echo "Workflow : ${WORKFLOW_NAME}"
echo "Steps    : ${STEP_COUNT}"
[[ -n "$WORKFLOW_DESC" ]] && echo "Info     : ${WORKFLOW_DESC}"
[[ "$DRY_RUN" == "true" ]] && echo "Mode     : DRY RUN (no changes)"
[[ "$SKIP_GATES" == "true" ]] && echo "Gates    : DISABLED"
echo ""

# ---------------------------------------------------------------------------
# Initialize state
# ---------------------------------------------------------------------------
STATE_DIR=$(init_state_dir)
export STATE_DIR
WORKFLOW_FAILED_STEPS=()

# Write initial workflow state BEFORE executing any step (compaction-resilient)
if command -v jq &>/dev/null && [[ -f "${STATE_DIR}/state.json" ]]; then
  CURRENT=$(cat "${STATE_DIR}/state.json" 2>/dev/null || echo "{}")
  UPDATED=$(echo "$CURRENT" | jq \
    --arg name "$WORKFLOW_NAME" \
    --arg file "$WORKFLOW_FILE" \
    '. + {"workflow": {"name": $name, "file": $file, "status": "running", "current_step": "", "checkpoints": {}}}')
  echo "$UPDATED" > "${STATE_DIR}/state.json.tmp.$$" && mv "${STATE_DIR}/state.json.tmp.$$" "${STATE_DIR}/state.json"
fi

# ---------------------------------------------------------------------------
# Execute steps
# ---------------------------------------------------------------------------
for i in $(seq 0 $((STEP_COUNT - 1))); do
  STEP_ID=$(jq -r ".steps[$i].id" "$WORKFLOW_FILE")
  STEP_SKILL=$(jq -r ".steps[$i].skill" "$WORKFLOW_FILE")
  STEP_ARGS=$(jq -r ".steps[$i].args // \"\"" "$WORKFLOW_FILE")
  STEP_DESTRUCTIVE=$(jq -r ".steps[$i].destructive // false" "$WORKFLOW_FILE")
  STEP_CHECKPOINT=$(jq -r ".steps[$i].checkpoint // false" "$WORKFLOW_FILE")
  STEP_COMMIT_MSG=$(jq -r ".steps[$i].commit_message // \"\"" "$WORKFLOW_FILE")

  # Expand env vars in args and commit message safely (envsubst only — no eval)
  export WORKFLOW_NAME STEP_ID
  STEP_ARGS=$(echo "$STEP_ARGS" | envsubst)
  [[ -n "$STEP_COMMIT_MSG" ]] && STEP_COMMIT_MSG=$(echo "$STEP_COMMIT_MSG" | envsubst)

  STEP_NUM=$((i + 1))
  echo "[${STEP_NUM}/${STEP_COUNT}] Step: ${STEP_ID}"
  echo "        Skill: ${STEP_SKILL} ${STEP_ARGS}"

  # Update current_step in state before execution
  if [[ -f "${STATE_DIR}/state.json" ]]; then
    CURRENT=$(cat "${STATE_DIR}/state.json" 2>/dev/null || echo "{}")
    echo "$CURRENT" | jq --arg s "$STEP_ID" '.workflow.current_step = $s' \
      > "${STATE_DIR}/state.json.tmp.$$" && mv "${STATE_DIR}/state.json.tmp.$$" "${STATE_DIR}/state.json"
  fi

  # Permission gate for destructive steps
  if [[ "$STEP_DESTRUCTIVE" == "true" && "$SKIP_GATES" == "false" && "$DRY_RUN" == "false" ]]; then
    if ! workflow_gate "$STEP_ID" "${STEP_SKILL} ${STEP_ARGS}"; then
      echo "  Skipping step '${STEP_ID}' — rejected by user."
      WORKFLOW_FAILED_STEPS+=("${STEP_ID}:skipped")
      continue
    fi
  fi

  # Dry-run: print and continue
  if [[ "$DRY_RUN" == "true" ]]; then
    echo "  [DRY RUN] Would execute: ${STEP_SKILL} ${STEP_ARGS}"
    continue
  fi

  # Execute step
  STEP_EXIT=0
  if ! ${STEP_SKILL} ${STEP_ARGS} 2>&1; then
    STEP_EXIT=$?
    echo "  ERROR: Step '${STEP_ID}' failed (exit ${STEP_EXIT})." >&2
    WORKFLOW_FAILED_STEPS+=("${STEP_ID}:failed")

    # Print rollback hints for all recorded checkpoints
    echo ""
    echo "  Rollback suggestions (run manually to revert):"
    if [[ -f "${STATE_DIR}/state.json" ]]; then
      jq -r '.workflow.checkpoints // {} | to_entries[] | "    git reset --hard \(.value.hash)  # revert to checkpoint: \(.key)"' \
        "${STATE_DIR}/state.json" 2>/dev/null || true
    fi
    echo ""
    # Continue to next step rather than abort — partial workflows are logged
  fi

  # Checkpoint: commit and record hash
  if [[ "$STEP_CHECKPOINT" == "true" && "$STEP_EXIT" -eq 0 ]]; then
    local_msg="${STEP_COMMIT_MSG:-workflow checkpoint: ${STEP_ID}}"
    workflow_checkpoint "$STEP_ID" "$local_msg"
  fi

  echo ""
done

# ---------------------------------------------------------------------------
# Update final workflow status
# ---------------------------------------------------------------------------
FINAL_STATUS="complete"
[[ ${#WORKFLOW_FAILED_STEPS[@]} -gt 0 ]] && FINAL_STATUS="partial"

if [[ -f "${STATE_DIR}/state.json" ]]; then
  CURRENT=$(cat "${STATE_DIR}/state.json" 2>/dev/null || echo "{}")
  echo "$CURRENT" | jq --arg s "$FINAL_STATUS" '.workflow.status = $s | .workflow.current_step = ""' \
    > "${STATE_DIR}/state.json.tmp.$$" && mv "${STATE_DIR}/state.json.tmp.$$" "${STATE_DIR}/state.json"
fi

# ---------------------------------------------------------------------------
# Post-workflow validation (ORCH-04)
# ---------------------------------------------------------------------------
if [[ "$DRY_RUN" == "false" ]]; then
  workflow_validate "$PLUGIN_ROOT" "$TEST_COMMAND"
fi

# ---------------------------------------------------------------------------
# Summary
# ---------------------------------------------------------------------------
echo ""
echo "=== Workflow Complete ==="
echo "Status : ${FINAL_STATUS}"
echo "Steps  : $((STEP_COUNT - ${#WORKFLOW_FAILED_STEPS[@]}))/${STEP_COUNT} succeeded"
if [[ ${#WORKFLOW_FAILED_STEPS[@]} -gt 0 ]]; then
  echo "Issues :"
  for entry in "${WORKFLOW_FAILED_STEPS[@]}"; do
    echo "  - ${entry}"
  done
fi
echo ""

[[ "$FINAL_STATUS" == "complete" ]] && exit 0 || exit 1
```

Then `chmod +x plugin/skills/workflow-orchestration/scripts/run-workflow.sh`

Key constraints:
- `export DEVSQUAD_HOOK_DEPTH=1` MUST be the first non-comment line after set options
- Use `BASH_SOURCE[0]:-$0` pattern for SCRIPT_DIR (matches generate-skill.sh)
- Use `envsubst` for variable expansion in args/commit_message (NOT eval — security)
- Write workflow state to state.json BEFORE executing each step (compaction-resilient per research)
- NEVER auto-execute `git reset --hard` — only print as informational suggestion
- `workflow_validate` is called once at the end, after all steps, NOT inside the loop
- Failure in one step does NOT abort subsequent steps — append to WORKFLOW_FAILED_STEPS and continue
  </action>
  <verify>
    bash -n plugin/skills/workflow-orchestration/scripts/run-workflow.sh
    grep -q "DEVSQUAD_HOOK_DEPTH=1" plugin/skills/workflow-orchestration/scripts/run-workflow.sh
    grep -q "source.*lib-workflow.sh" plugin/skills/workflow-orchestration/scripts/run-workflow.sh
    grep -q "workflow_gate\|workflow_checkpoint\|workflow_validate" plugin/skills/workflow-orchestration/scripts/run-workflow.sh
    grep -q "envsubst" plugin/skills/workflow-orchestration/scripts/run-workflow.sh
    bash plugin/skills/workflow-orchestration/scripts/run-workflow.sh --dry-run --workflow plugin/skills/workflow-orchestration/templates/feature-workflow.json 2>&1 | grep -q "DRY RUN"
  </verify>
  <done>
    run-workflow.sh passes bash -n, exports DEVSQUAD_HOOK_DEPTH=1, sources lib-workflow.sh, calls all three helper functions, uses envsubst for expansion, and --dry-run mode prints steps without executing them.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create workflow.md command stub</name>
  <files>plugin/commands/workflow.md</files>
  <action>
Create `plugin/commands/workflow.md` following the exact thin-wrapper pattern from `plugin/commands/generate.md`:

```markdown
---
description: Run a multi-step DevSquad workflow from a JSON definition file, with permission gates, auto-commits at checkpoints, and post-workflow validation
argument-hint: "--workflow <path-to-workflow.json> [--dry-run] [--skip-gates]"
allowed-tools: ["Read", "Write", "Bash", "Skill"]
---

# DevSquad Workflow

Arguments: $ARGUMENTS

Invoke the devsquad:workflow-orchestration skill with the provided arguments and follow it exactly.
```

Key constraints:
- `description` must be a single line (no newlines)
- `allowed-tools` must include `Bash` (script execution) and `Write` (checkpoint state writes)
- The body instruction must reference `devsquad:workflow-orchestration` — that is the skill name from SKILL.md
- `$ARGUMENTS` passes user arguments through unchanged to the skill
  </action>
  <verify>
    test -f plugin/commands/workflow.md
    grep -q "devsquad:workflow-orchestration" plugin/commands/workflow.md
    grep -q "argument-hint" plugin/commands/workflow.md
    python3 -c "
import re, sys
content = open('plugin/commands/workflow.md').read()
# Check frontmatter present
assert content.startswith('---'), 'Missing frontmatter'
# Check required fields
assert 'description:' in content, 'Missing description'
assert 'allowed-tools:' in content, 'Missing allowed-tools'
print('workflow.md structure valid')
"
  </verify>
  <done>
    workflow.md exists with valid frontmatter, references devsquad:workflow-orchestration, and follows the thin-wrapper pattern from generate.md.
  </done>
</task>

</tasks>

<verification>
# Syntax check
bash -n plugin/skills/workflow-orchestration/scripts/run-workflow.sh

# Critical pattern checks
grep -q "DEVSQUAD_HOOK_DEPTH=1" plugin/skills/workflow-orchestration/scripts/run-workflow.sh && echo "HOOK_DEPTH: OK"
grep -q "workflow_gate" plugin/skills/workflow-orchestration/scripts/run-workflow.sh && echo "gate: OK"
grep -q "workflow_checkpoint" plugin/skills/workflow-orchestration/scripts/run-workflow.sh && echo "checkpoint: OK"
grep -q "workflow_validate" plugin/skills/workflow-orchestration/scripts/run-workflow.sh && echo "validate: OK"
grep -q "git reset --hard" plugin/skills/workflow-orchestration/scripts/run-workflow.sh && echo "rollback hints: OK"

# Dry-run smoke test
bash plugin/skills/workflow-orchestration/scripts/run-workflow.sh \
  --dry-run \
  --workflow plugin/skills/workflow-orchestration/templates/feature-workflow.json

# Command stub
grep -q "devsquad:workflow-orchestration" plugin/commands/workflow.md && echo "command stub: OK"
</verification>

<success_criteria>
- run-workflow.sh passes bash -n with no errors
- DEVSQUAD_HOOK_DEPTH=1 exported at top
- All three lib-workflow.sh functions called in the driver
- envsubst used for variable expansion (not eval)
- --dry-run mode prints all steps without executing any commands
- Rollback hints printed on failure but no auto-execution of git reset
- workflow.md follows thin-wrapper pattern and references correct skill name
</success_criteria>

<output>
After completion, create `.planning/phases/04-workflow-orchestration/04-02-SUMMARY.md` following the summary template at @/Users/Dikshant/.claude/get-shit-done/templates/summary.md
</output>
