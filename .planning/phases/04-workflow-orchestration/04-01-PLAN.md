---
phase: 04-workflow-orchestration
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - plugin/skills/workflow-orchestration/SKILL.md
  - plugin/skills/workflow-orchestration/scripts/lib-workflow.sh
  - plugin/skills/workflow-orchestration/templates/feature-workflow.json
autonomous: true
requirements:
  - ORCH-01
  - ORCH-02
  - ORCH-03
  - ORCH-04

must_haves:
  truths:
    - "A feature-workflow.json template exists that defines a named sequence of steps with skill, args, destructive, checkpoint, and commit_message fields"
    - "workflow_gate function prompts the user via /dev/tty before any destructive step and aborts cleanly on rejection"
    - "workflow_checkpoint function records a git commit hash into state.json under workflow.checkpoints before returning"
    - "workflow_validate function runs git-health.sh --json and an optional test_command, printing a summary"
    - "SKILL.md correctly describes when to invoke the workflow-orchestration skill"
  artifacts:
    - path: "plugin/skills/workflow-orchestration/SKILL.md"
      provides: "Skill metadata and invocation guidance"
      contains: "name: workflow-orchestration"
    - path: "plugin/skills/workflow-orchestration/scripts/lib-workflow.sh"
      provides: "Helper functions: workflow_gate, workflow_checkpoint, workflow_validate"
      exports: ["workflow_gate", "workflow_checkpoint", "workflow_validate"]
    - path: "plugin/skills/workflow-orchestration/templates/feature-workflow.json"
      provides: "Example workflow definition with 4 steps"
      contains: "steps"
  key_links:
    - from: "plugin/skills/workflow-orchestration/scripts/run-workflow.sh"
      to: "plugin/skills/workflow-orchestration/scripts/lib-workflow.sh"
      via: "source lib-workflow.sh"
      pattern: "source.*lib-workflow\\.sh"
    - from: "workflow_gate"
      to: "/dev/tty"
      via: "read -r REPLY </dev/tty"
      pattern: "read.*</dev/tty"
    - from: "workflow_checkpoint"
      to: ".devsquad/state.json"
      via: "update_state_key workflow.checkpoints"
      pattern: "update_state_key.*workflow"
---

<objective>
Create the foundational library and metadata for the workflow-orchestration skill.

Purpose: The lib-workflow.sh helper library contains the three core capabilities that all other plans depend on — permission gates (/dev/tty prompts), checkpoint recording (git hash → state.json), and post-workflow validation (git-health + test runner). SKILL.md and the feature-workflow.json template define the skill interface and demonstrate the workflow definition format.

Output: lib-workflow.sh with three exported functions, SKILL.md, and feature-workflow.json.
</objective>

<execution_context>
@/Users/Dikshant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Dikshant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@plugin/lib/state.sh
@plugin/skills/code-generation/SKILL.md
@plugin/skills/git-health/scripts/git-health.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib-workflow.sh helper library</name>
  <files>plugin/skills/workflow-orchestration/scripts/lib-workflow.sh</files>
  <action>
Create the directory `plugin/skills/workflow-orchestration/scripts/` and write `lib-workflow.sh`:

```bash
#!/usr/bin/env bash
# lib-workflow.sh — Helper functions for workflow-orchestration skill
# Sourced by run-workflow.sh. Do not execute directly.
# shellcheck disable=SC2034

# --- workflow_gate -----------------------------------------------------------
# Prompts the user for confirmation before a destructive step.
# Usage: workflow_gate "step_id" "description"
# Returns: 0 if approved, 1 if rejected (caller should exit or skip)
workflow_gate() {
  local step_id="$1"
  local description="${2:-this step}"

  echo ""
  echo "  [GATE] Step '${step_id}' is marked destructive:"
  echo "         ${description}"
  echo ""
  printf "  Proceed? [y/N] "

  local REPLY
  read -r REPLY </dev/tty

  echo ""
  case "$REPLY" in
    y|Y|yes|YES)
      echo "  Approved — continuing."
      return 0
      ;;
    *)
      echo "  Rejected — skipping step '${step_id}'."
      return 1
      ;;
  esac
}

# --- workflow_checkpoint -----------------------------------------------------
# Records current git HEAD hash into state.json under workflow.checkpoints.<step_id>
# Also performs a git commit if there are staged/unstaged changes.
# Usage: workflow_checkpoint "step_id" "commit_message"
# Requires: STATE_DIR set by caller, update_state_key sourced from lib/state.sh
workflow_checkpoint() {
  local step_id="$1"
  local commit_message="${2:-workflow checkpoint: ${step_id}}"
  local state_file="${STATE_DIR}/state.json"

  echo "  [CHECKPOINT] Recording checkpoint for step '${step_id}'..."

  # Only commit if there are actual changes (avoid empty commit error)
  if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
    git add -A
    git commit -m "${commit_message}" --no-verify 2>/dev/null || true
    echo "  Committed changes: ${commit_message}"
  else
    echo "  No changes to commit at this checkpoint."
  fi

  # Record the current HEAD hash regardless
  local head_hash
  head_hash=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
  echo "  HEAD hash: ${head_hash}"

  # Persist to state.json under workflow.checkpoints.<step_id>
  if command -v jq &>/dev/null && [[ -f "$state_file" ]]; then
    local current updated
    current=$(cat "$state_file" 2>/dev/null || echo "{}")
    updated=$(echo "$current" | jq \
      --arg step "$step_id" \
      --arg hash "$head_hash" \
      --arg msg "$commit_message" \
      '.workflow.checkpoints[$step] = {"hash": $hash, "message": $msg, "timestamp": (now | todate)}')
    echo "$updated" > "${state_file}.tmp.$$" && mv "${state_file}.tmp.$$" "$state_file"
    echo "  State persisted: workflow.checkpoints.${step_id}"
  else
    echo "  WARNING: jq not available or state.json missing — checkpoint hash not persisted." >&2
  fi
}

# --- workflow_validate -------------------------------------------------------
# Runs post-workflow health checks: git-health.sh --json + optional test_command.
# Usage: workflow_validate "plugin_root" "test_command"
# Prints a human-readable summary and sets exit code 0 on pass, 1 on failure.
workflow_validate() {
  local plugin_root="$1"
  local test_command="${2:-}"
  local health_script="${plugin_root}/skills/git-health/scripts/git-health.sh"
  local all_passed=true

  echo ""
  echo "=== Post-Workflow Validation ==="
  echo ""

  # Git health check
  echo "[1/2] Running git health check..."
  if [[ -x "$health_script" ]]; then
    local health_json
    health_json=$("$health_script" --json 2>/dev/null || echo '{"status":"error"}')
    local health_status
    health_status=$(echo "$health_json" | jq -r '.status // "unknown"' 2>/dev/null || echo "unknown")
    echo "      Git health: ${health_status}"
    if [[ "$health_status" != "healthy" && "$health_status" != "ok" ]]; then
      echo "      WARNING: Git health check reported issues."
      all_passed=false
    fi
  else
    echo "      SKIP: git-health.sh not found or not executable."
  fi

  # Optional test command
  echo "[2/2] Running tests..."
  if [[ -n "$test_command" ]]; then
    echo "      Command: ${test_command}"
    if eval "$test_command" 2>&1 | tail -5; then
      echo "      Tests: PASSED"
    else
      echo "      Tests: FAILED"
      all_passed=false
    fi
  else
    echo "      SKIP: No test_command configured."
  fi

  echo ""
  if [[ "$all_passed" == "true" ]]; then
    echo "Validation: PASSED"
    return 0
  else
    echo "Validation: FAILED — review issues above."
    return 1
  fi
}
```

Ensure the file is executable: `chmod +x plugin/skills/workflow-orchestration/scripts/lib-workflow.sh`

Key constraints:
- All three functions (`workflow_gate`, `workflow_checkpoint`, `workflow_validate`) MUST be present
- `workflow_gate` MUST use `read -r REPLY </dev/tty` (not plain `read`) — piped context safety
- `workflow_checkpoint` MUST check `git diff --quiet && git diff --cached --quiet` before committing to avoid empty commit errors
- `workflow_checkpoint` writes to `workflow.checkpoints.<step_id>` namespace in state.json
- `workflow_validate` calls `git-health.sh --json` and pipes output through jq for status check
- Follow the atomic write pattern from state.sh: write to `.tmp.$$` then `mv`
  </action>
  <verify>
    bash -n plugin/skills/workflow-orchestration/scripts/lib-workflow.sh
    grep -q "workflow_gate\|workflow_checkpoint\|workflow_validate" plugin/skills/workflow-orchestration/scripts/lib-workflow.sh
    grep -q "read.*</dev/tty" plugin/skills/workflow-orchestration/scripts/lib-workflow.sh
    grep -q "git diff --quiet" plugin/skills/workflow-orchestration/scripts/lib-workflow.sh
  </verify>
  <done>
    lib-workflow.sh passes bash syntax check (bash -n), contains all three functions, uses /dev/tty for gate, checks git diff before commit. File is executable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SKILL.md and feature-workflow.json template</name>
  <files>
    plugin/skills/workflow-orchestration/SKILL.md
    plugin/skills/workflow-orchestration/templates/feature-workflow.json
  </files>
  <action>
Create `plugin/skills/workflow-orchestration/SKILL.md`:

```markdown
---
name: workflow-orchestration
description: This skill should be used when the user asks to "run a workflow", "chain skills together", "execute a feature workflow", or wants to automate a multi-step process (create feature branch → generate code → test → clean up).
version: 1.0.0
---

# Workflow Orchestration Skill

Chains multiple DevSquad skills into an autonomous, feature-complete workflow that executes with minimal user intervention. Reads a JSON workflow definition file, executes steps sequentially, gates destructive operations with user permission prompts, auto-commits at checkpoints, and validates the result.

## When to Use

Use this skill when the user:
- Wants to run a pre-defined multi-step workflow (e.g., "run the feature workflow for issue-42")
- Asks to "chain" multiple skills or automate a sequence of operations
- Mentions a workflow file (e.g., "use feature-workflow.json")
- Wants a repeatable, auditable process for common development patterns

## Invocation

```bash
bash plugin/skills/workflow-orchestration/scripts/run-workflow.sh \
  --workflow plugin/skills/workflow-orchestration/templates/feature-workflow.json \
  [--dry-run] \
  [--skip-gates]
```

## Arguments

| Argument | Required | Description |
|----------|----------|-------------|
| `--workflow <path>` | Yes | Path to the JSON workflow definition file |
| `--dry-run` | No | Print steps without executing them |
| `--skip-gates` | No | Skip destructive-step confirmation prompts (use with caution) |

## Workflow JSON Format

See `templates/feature-workflow.json` for a complete example. Each step has:
- `id` — unique step identifier (used as checkpoint key)
- `skill` — shell command or script to invoke
- `args` — string of arguments passed to the skill
- `destructive` — boolean, gates with user prompt if true
- `checkpoint` — boolean, auto-commits and records hash if true
- `commit_message` — optional message template (supports `$WORKFLOW_NAME`, `$STEP_ID` env vars)
```

Create `plugin/skills/workflow-orchestration/templates/feature-workflow.json`:

```json
{
  "name": "feature-workflow",
  "description": "End-to-end feature development: create branch, generate skill, validate, and clean up staging files.",
  "test_command": "",
  "steps": [
    {
      "id": "branch-create",
      "skill": "git",
      "args": "checkout -b feature/$FEATURE_NAME",
      "destructive": false,
      "checkpoint": false,
      "commit_message": ""
    },
    {
      "id": "generate-skill",
      "skill": "bash",
      "args": "plugin/skills/code-generation/scripts/generate-skill.sh \"$FEATURE_DESCRIPTION\" --name $FEATURE_NAME",
      "destructive": false,
      "checkpoint": true,
      "commit_message": "feat($WORKFLOW_NAME): generate $FEATURE_NAME skill scaffold"
    },
    {
      "id": "validate",
      "skill": "bash",
      "args": "plugin/skills/git-health/scripts/git-health.sh",
      "destructive": false,
      "checkpoint": false,
      "commit_message": ""
    },
    {
      "id": "cleanup-staging",
      "skill": "bash",
      "args": "rm -f .devsquad/staging/*.tmp 2>/dev/null || true",
      "destructive": true,
      "checkpoint": true,
      "commit_message": "chore($WORKFLOW_NAME): cleanup staging files after $STEP_ID"
    }
  ]
}
```

Key constraints:
- SKILL.md frontmatter `name` field MUST be `workflow-orchestration`
- feature-workflow.json MUST have at least one step with `destructive: true` (demonstrates ORCH-02)
- feature-workflow.json MUST have at least one step with `checkpoint: true` (demonstrates ORCH-03)
- The cleanup step demonstrates ORCH-04 post-workflow validation
- `commit_message` fields use `$WORKFLOW_NAME` and `$STEP_ID` — these are expanded via envsubst in run-workflow.sh
  </action>
  <verify>
    test -f plugin/skills/workflow-orchestration/SKILL.md
    test -f plugin/skills/workflow-orchestration/templates/feature-workflow.json
    python3 -c "import json; json.load(open('plugin/skills/workflow-orchestration/templates/feature-workflow.json'))" 2>&1
    grep -q "name: workflow-orchestration" plugin/skills/workflow-orchestration/SKILL.md
    python3 -c "import json; d=json.load(open('plugin/skills/workflow-orchestration/templates/feature-workflow.json')); assert any(s['destructive'] for s in d['steps']); assert any(s['checkpoint'] for s in d['steps']); print('JSON valid')"
  </verify>
  <done>
    SKILL.md exists with correct name frontmatter. feature-workflow.json is valid JSON with at least one destructive step and one checkpoint step.
  </done>
</task>

</tasks>

<verification>
bash -n plugin/skills/workflow-orchestration/scripts/lib-workflow.sh
grep -c "workflow_gate\|workflow_checkpoint\|workflow_validate" plugin/skills/workflow-orchestration/scripts/lib-workflow.sh
python3 -c "import json; d=json.load(open('plugin/skills/workflow-orchestration/templates/feature-workflow.json')); print('steps:', len(d['steps']))"
grep "name: workflow-orchestration" plugin/skills/workflow-orchestration/SKILL.md
</verification>

<success_criteria>
- lib-workflow.sh passes bash -n syntax check and contains all three functions
- workflow_gate uses read -r REPLY &lt;/dev/tty
- workflow_checkpoint checks git diff before committing and writes to state.json
- feature-workflow.json is valid JSON with at least one destructive step and one checkpoint step
- SKILL.md has correct name frontmatter
</success_criteria>

<output>
After completion, create `.planning/phases/04-workflow-orchestration/04-01-SUMMARY.md` following the summary template at @/Users/Dikshant/.claude/get-shit-done/templates/summary.md
</output>
